{% extends "base.html" %}

{% block title %}Work Progress Monitor - CSPBench{% endblock %}

{% block breadcrumb_items %}
<li class="breadcrumb-item"><a href="/monitor/works" class="text-decoration-none"><i
      class="bi bi-speedometer2 me-1"></i>Work Monitor</a></li>
<li class="breadcrumb-item active" aria-current="page"><i class="bi bi-activity me-1"></i>{{ work_id or 'work_id' }}
</li>
{% endblock %}

{% block header %}{% endblock %}

{% block extra_css %}
<style>
  .monitor-progress-bg {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 2rem 0;
  }

  .monitor-container {
    max-width: 1400px;
    margin: 0 auto;
  }

  .monitor-card {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, .08);
    margin-bottom: 1.75rem;
    overflow: hidden;
  }

  .monitor-card .card-header {
    background: #f8f9fa;
    border-bottom: 1px solid #e5e7eb;
    font-weight: 600;
  }

  /* Pain√©is internos do resumo */
  .summary-panel {
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 14px;
    padding: 1.1rem 1.2rem;
    height: 100%;
    display: flex;
    flex-direction: column;
    box-shadow: 0 2px 6px rgba(0, 0, 0, .04);
  }

  .summary-panel h6 {
    font-size: .8rem;
    text-transform: uppercase;
    letter-spacing: .6px;
    font-weight: 600;
    color: #6c757d;
    margin: 0 0 .85rem 0;
    display: flex;
    align-items: center;
    gap: .4rem;
  }

  .summary-panel h6 i {
    font-size: .9rem;
  }

  .summary-panel:not(.no-hover) {
    transition: box-shadow .25s ease, transform .25s ease;
  }

  .summary-panel:not(.no-hover):hover {
    box-shadow: 0 6px 18px rgba(0, 0, 0, .08);
    transform: translateY(-2px);
  }

  /* M√©tricas */
  .metric-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: .9rem;
    width: 100%;
  }

  .metric-box {
    background: linear-gradient(180deg, #fafbfc 0%, #f1f3f5 100%);
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: .75rem .85rem;
    display: flex;
    gap: .65rem;
    align-items: center;
    position: relative;
    overflow: hidden;
  }

  .metric-box:before {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at top left, rgba(102, 126, 234, .15), transparent 70%);
    pointer-events: none;
  }

  .metric-icon {
    width: 42px;
    height: 42px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1rem;
  }

  .metric-value {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0;
  }

  .metric-label {
    font-size: .75rem;
    text-transform: uppercase;
    letter-spacing: .5px;
    margin: 0;
    color: #6c757d
  }

  .progress-slim {
    height: 10px;
    border-radius: 5px;
  }

  .nav-tabs .nav-link {
    font-weight: 500;
  }

  .placeholder-box {
    border: 2px dashed #ced4da;
    border-radius: 10px;
    padding: 2rem;
    text-align: center;
    color: #6c757d;
  }

  .status-badge {
    font-size: .75rem;
    letter-spacing: .5px;
  }

  .hierarchy-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .hierarchy-list li {
    display: flex;
    justify-content: space-between;
    padding: .35rem .5rem;
    font-size: .85rem;
    border-radius: 6px;
  }

  .hierarchy-list li span {
    max-width: 60%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .hierarchy-list li.active {
    background: #eef5ff;
    font-weight: 600;
  }

  .table-placeholder {
    min-height: 240px;
  }

  .event-log-placeholder {
    min-height: 220px;
  }

  .progress-ring-wrapper {
    width: 140px;
    height: 140px;
    position: relative;
  }

  .progress-ring-wrapper .percent {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 1.25rem;
  }

  /* Auto-follow button styles */
  #autoFollowBtn.active {
    background-color: #667eea;
    border-color: #667eea;
    color: white;
  }

  #autoFollowBtn.active:hover {
    background-color: #5a6fd8;
    border-color: #5a6fd8;
  }

  /* Highlight current running execution */
  .table-info {
    background-color: rgba(102, 126, 234, 0.1) !important;
  }

  /* Scroll containers */
  .scroll-y {
    max-height: 260px;
    overflow-y: auto;
  }

  /* Executions table with fixed header */
  #executionsContainer {
    position: relative;
  }

  #executionsContainer .sticky-top {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #f8f9fa;
  }

  #executionsContainer::-webkit-scrollbar {
    width: 6px;
  }

  #executionsContainer::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
  }

  #executionsContainer::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
  }

  #executionsContainer::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
  }

  .small-label {
    font-size: .65rem;
    text-transform: uppercase;
    letter-spacing: .5px;
    color: #6c757d;
  }

  /* Event log styles */
  .event-type-error {
    background-color: #dc3545;
    color: white;
  }

  .event-type-warning {
    background-color: #ffc107;
    color: #212529;
  }

  .event-type-progress {
    background-color: #0dcaf0;
    color: #212529;
  }

  .event-timestamp {
    font-family: 'Courier New', monospace;
    font-size: 0.75rem;
  }

  .event-data {
    font-size: 0.8rem;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .event-data-expanded {
    max-width: none;
    white-space: pre-wrap;
    word-break: break-word;
  }

  #btnAutoScroll.active {
    background-color: #198754;
    border-color: #198754;
    color: white;
  }

  /* Ajustes responsivos */
  @media (max-width: 1199.98px) {
    .progress-ring-wrapper {
      width: 120px;
      height: 120px;
    }

    .metric-value {
      font-size: 1.1rem;
    }
  }
</style>
{% endblock %}

{% block content %}
<div class="monitor-progress-bg">
  <div class="monitor-container">
    <!-- T√≠tulo -->
    <div class="text-center text-white mb-5">
      <h1 class="display-5 fw-bold mb-2"><i class="bi bi-activity me-3"></i>Work Progress Monitor</h1>
      <p class="lead mb-0">Monitoramento em tempo real do progresso de execu√ß√£o</p>
    </div>

    <!-- Resumo Global -->
    <div class="monitor-card">
      <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-3">
        <div class="d-flex align-items-center gap-2">
          <h5 class="mb-0"><i class="bi bi-graph-up me-2"></i>Resumo</h5>
          <span class="badge bg-secondary status-badge" id="workStatusBadge">STATUS</span>
          <span class="ms-3 small text-muted d-flex align-items-center" id="startTimeWrapper"><i
              class="bi bi-play-circle me-1"></i><span id="startTime">--</span></span>
        </div>
        <div class="d-flex flex-column align-items-end gap-1">
          <div class="small text-muted">
            <i class="bi bi-file-earmark-text me-1"></i>
            <span id="batchName">Carregando...</span>
          </div>
          <div class="d-flex flex-wrap gap-2" id="workActions">
            <!-- Bot√µes de controle -->
            <button class="btn btn-outline-warning btn-sm" id="btnPauseWork" title="Pausar execu√ß√£o"
              style="display: none;">
              <span class="btn-content"><i class="bi bi-pause-fill me-1"></i>Pausar</span>
              <span class="btn-loading d-none"><span class="spinner-border spinner-border-sm me-1" role="status"
                  aria-hidden="true"></span>Pausando...</span>
            </button>
            <button class="btn btn-outline-success btn-sm" id="btnContinueWork" title="Continuar execu√ß√£o"
              style="display: none;">
              <span class="btn-content"><i class="bi bi-play-fill me-1"></i>Continuar</span>
              <span class="btn-loading d-none"><span class="spinner-border spinner-border-sm me-1" role="status"
                  aria-hidden="true"></span>Continuando...</span>
            </button>
            <!-- Bot√£o para ir ao resultado -->
            <button class="btn btn-outline-info btn-sm" id="btnGoToResult" title="Ver resultado"><i
                class="bi bi-box-arrow-up-right me-1"></i>Resultado</button>
            <a href="/monitor/works" class="btn btn-outline-secondary btn-sm"><i
                class="bi bi-arrow-left me-1"></i>Voltar</a>
          </div>
        </div>
      </div>
      <div class="card-body">
        <!-- Linha removida: Current Context movido para coluna direita -->
        <div class="row g-4 align-items-stretch">
          <!-- Hierarchy (agora √† esquerda) -->
          <div class="col-xl-4 d-flex">
            <div class="summary-panel w-100" id="panelHierarchy">
              <h6><i class="bi bi-diagram-3"></i>Hierarchy</h6>
              <ul class="hierarchy-list mb-3 flex-grow-1" id="hierarchyList">
                <li class="active"><span>Task</span><span id="taskProgress">0/0</span></li>
                <li><span>Dataset</span><span id="datasetProgress">0/0</span></li>
                <li><span>Config</span><span id="configProgress">0/0</span></li>
                <li><span>Algorithm</span><span id="algorithmProgress">0/0</span></li>
              </ul>
              <!-- Current removido deste painel -->
            </div>
          </div>
          <!-- Progress Ring (centro) simplificado -->
          <div class="col-xl-4 d-flex">
            <div class="summary-panel w-100 d-flex flex-column align-items-center justify-content-center"
              id="panelProgress">
              <div class="progress-ring-wrapper mb-2">
                <div class="percent" id="progressPercent">0%</div>
                <svg width="140" height="140">
                  <circle cx="70" cy="70" r="60" stroke="#e9ecef" stroke-width="12" fill="none" />
                  <circle cx="70" cy="70" r="60" stroke="#667eea" stroke-width="12" fill="none" stroke-dasharray="0 999"
                    stroke-linecap="round" id="progressCircle" />
                </svg>
              </div>
              <div class="small text-muted" id="progressRatio">0/0</div>
            </div>
          </div>
          <!-- Current Context (coluna direita) -->
          <div class="col-xl-4 d-flex">
            <div class="summary-panel w-100" id="panelCurrentContext">
              <h6><i class="bi bi-compass"></i>Current Context</h6>
              <ul class="hierarchy-list mb-0" id="currentContextList">
                <li><span>Task</span><span id="currentTaskValue">‚Äî</span></li>
                <li><span>Dataset</span><span id="currentDatasetValue">‚Äî</span></li>
                <li><span>Config</span><span id="currentConfigValue">‚Äî</span></li>
                <li><span>Algorithm</span><span id="currentAlgorithmValue">‚Äî</span></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tabs Principal -->
    <div class="monitor-card">
      <div class="card-header">
        <ul class="nav nav-tabs card-header-tabs" id="monitorTabs" role="tablist">
          <li class="nav-item" role="presentation"><button class="nav-link active" data-bs-toggle="tab"
              data-bs-target="#tab-executions" type="button" role="tab"><i
                class="bi bi-list-task me-1"></i>Executions</button></li>
          <li class="nav-item" role="presentation"><button class="nav-link" data-bs-toggle="tab"
              data-bs-target="#tab-events" type="button" role="tab"><i
                class="bi bi-journal-text me-1"></i>Events</button></li>
        </ul>
      </div>
      <div class="card-body tab-content">
        <!-- Executions Tab -->
        <div class="tab-pane fade show active" id="tab-executions" role="tabpanel">
          <div class="row g-2 mb-3 align-items-center">
            <div class="col-lg-4 col-md-5">
              <label class="form-label small text-uppercase fw-semibold text-muted mb-1 d-flex align-items-center"><i
                  class="bi bi-filter-square me-1"></i>Combina√ß√£o</label>
              <div class="d-flex gap-2 align-items-center combo-filter-wrapper">
                <select class="form-select form-select-sm" id="combinationSelect"></select>
                <button class="btn btn-sm btn-outline-secondary" id="autoFollowBtn"
                  title="Seguir execu√ß√£o atual automaticamente">
                  <i class="bi bi-magnet" id="autoFollowIcon"></i>
                </button>
              </div>
            </div>
            <div class="col-lg-8 col-md-7">
              <div class="row g-2" id="executionStats">
                <div class="col-6 col-lg-3">
                  <div class="border rounded p-2 text-center small">
                    <div class="text-muted">Running</div>
                    <div class="fw-bold" id="statRunning">0</div>
                  </div>
                </div>
                <div class="col-6 col-lg-3">
                  <div class="border rounded p-2 text-center small">
                    <div class="text-muted">Completed</div>
                    <div class="fw-bold text-success" id="statCompleted">0</div>
                  </div>
                </div>
                <div class="col-6 col-lg-3">
                  <div class="border rounded p-2 text-center small">
                    <div class="text-muted">Queued</div>
                    <div class="fw-bold text-info" id="statQueued">0</div>
                  </div>
                </div>
                <div class="col-6 col-lg-3">
                  <div class="border rounded p-2 text-center small">
                    <div class="text-muted">Failed</div>
                    <div class="fw-bold text-danger" id="statFailed">0</div>
                  </div>
                </div>
                <div class="col-12 mt-2">
                  <div class="progress" style="height:8px;">
                    <div class="progress-bar" id="comboProgressBar" style="width:0%"></div>
                  </div>
                  <div class="d-flex justify-content-between small mt-1">
                    <span id="comboProgressLabel">0/0</span>
                    <span class="text-muted" id="comboMetaLabel">Total (repeti√ß√µes)</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="table-responsive table-placeholder border rounded"
            style="min-height:260px; max-height:400px; overflow-y:auto;" id="executionsContainer">
            <table class="table table-sm align-middle mb-0" id="executionsTable">
              <thead class="table-light sticky-top">
                <tr>
                  <th style="width:70px">#</th>
                  <th>Status</th>
                  <th style="width:160px">Progress</th>
                  <th style="width:110px">In√≠cio</th>
                  <th style="width:110px">Fim</th>
                  <th>Mensagem</th>
                </tr>
              </thead>
              <tbody id="executionsTableBody">
                <tr>
                  <td colspan="6" class="text-center text-muted py-4"><i class="bi bi-inbox me-1"></i>Nenhuma execu√ß√£o
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <!-- Info de execu√ß√µes sem pagina√ß√£o -->
          <div class="d-flex justify-content-between align-items-center mt-2">
            <div class="text-muted small">
              <span id="executionsInfo">Mostrando 0 execu√ß√µes</span>
            </div>
          </div>
        </div>
        <!-- Events Tab -->
        <div class="tab-pane fade" id="tab-events" role="tabpanel">
          <!-- Filtros -->
          <div class="row g-2 mb-3 align-items-end">
            <div class="col-md-2">
              <label class="form-label small text-uppercase fw-semibold text-muted mb-1">Tipo</label>
              <select class="form-select form-select-sm" id="eventTypeFilter">
                <option value="">Todos</option>
                <option value="error">Error</option>
                <option value="warning">Warning</option>
                <option value="progress">Progress</option>
              </select>
            </div>
            <div class="col-md-2">
              <label class="form-label small text-uppercase fw-semibold text-muted mb-1">Categoria</label>
              <select class="form-select form-select-sm" id="eventCategoryFilter">
                <option value="">Todas</option>
                <option value="work">Work</option>
                <option value="task">Task</option>
                <option value="dataset">Dataset</option>
                <option value="preset">Preset</option>
                <option value="combination">Combination</option>
                <option value="unit">Unit</option>
                <option value="other">Other</option>
              </select>
            </div>
            <div class="col-md-3">
              <label class="form-label small text-uppercase fw-semibold text-muted mb-1">Filtro de Texto</label>
              <input type="text" class="form-control form-control-sm" id="eventTextFilter"
                placeholder="Buscar no entity_data...">
            </div>
            <div class="col-md-2">
              <label class="form-label small text-uppercase fw-semibold text-muted mb-1">Data In√≠cio</label>
              <input type="datetime-local" class="form-control form-control-sm" id="eventDateFromFilter">
            </div>
            <div class="col-md-2">
              <label class="form-label small text-uppercase fw-semibold text-muted mb-1">Data Fim</label>
              <input type="datetime-local" class="form-control form-control-sm" id="eventDateToFilter">
            </div>
            <div class="col-md-1 d-flex align-items-end">
              <button class="btn btn-outline-success btn-sm" id="btnAutoScroll"
                title="Auto-refresh para primeira p√°gina">
                <i class="bi bi-arrow-clockwise"></i>
              </button>
            </div>
          </div>

          <!-- Event Log Container -->
          <div class="border rounded">
            <div class="table-responsive">
              <table class="table table-sm table-hover mb-0" id="eventLogTable">
                <thead class="table-light">
                  <tr>
                    <th style="width: 120px">Timestamp</th>
                    <th style="width: 80px">Tipo</th>
                    <th style="width: 100px">Categoria</th>
                    <th>Dados</th>
                  </tr>
                </thead>
                <tbody id="eventLogTableBody">
                  <tr>
                    <td colspan="4" class="text-center text-muted py-4">
                      <i class="bi bi-inbox me-1"></i>Nenhum evento encontrado
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Pagina√ß√£o para Events -->
          <div class="d-flex justify-content-between align-items-center mt-3">
            <div class="text-muted small">
              <span id="eventsInfo">Mostrando 0 de 0 eventos</span>
            </div>
            <nav aria-label="Events pagination">
              <ul class="pagination pagination-sm mb-0" id="eventsPagination">
                <!-- Pagina√ß√£o ser√° gerada via JavaScript -->
              </ul>
            </nav>
          </div>

          <!-- Statistics -->
          <div class="row g-2 mt-2">
            <div class="col-md-3">
              <div class="text-center p-2 border rounded">
                <div class="small text-muted">Total</div>
                <div class="fw-bold" id="eventStatsTotal">0</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="text-center p-2 border rounded">
                <div class="small text-muted">Errors</div>
                <div class="fw-bold text-danger" id="eventStatsErrors">0</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="text-center p-2 border rounded">
                <div class="small text-muted">Warnings</div>
                <div class="fw-bold text-warning" id="eventStatsWarnings">0</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="text-center p-2 border rounded">
                <div class="small text-muted">Progress</div>
                <div class="fw-bold text-info" id="eventStatsProgress">0</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal Placeholder -->
    <div class="modal fade" id="executionModal" tabindex="-1" aria-labelledby="executionModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="executionModalLabel"><i class="bi bi-search me-2"></i>Execution Details</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="placeholder-box py-5">Detalhes da execu√ß√£o (placeholder)</div>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
  // === Vari√°veis Globais ===
  const ITEMS_PER_PAGE = 10;

  // === Scheduler de DOM Ass√≠ncrono (coalescente) ===
  const DOMScheduler = (() => {
    const jobs = new Map(); // key -> fn
    let scheduled = false;
    let lastRun = 0;
    const minIntervalMs = 50; // limita ~20fps para reduzir carga

    function flush() {
      scheduled = false;
      const now = performance.now();
      const delay = Math.max(0, minIntervalMs - (now - lastRun));
      setTimeout(() => {
        requestAnimationFrame(() => {
          lastRun = performance.now();
          const pending = Array.from(jobs.values());
          jobs.clear();
          for (const fn of pending) {
            try { fn(); } catch (e) { console.warn('DOMScheduler job error:', e); }
          }
        });
      }, delay);
    }

    return {
      schedule(key, fn) {
        jobs.set(key, fn);
        if (!scheduled) {
          scheduled = true;
          flush();
        }
      }
    };
  })();

  // Wrappers para renderiza√ß√µes pesadas (globais, apenas para fun√ß√µes globais)
  function scheduleRenderExecutionsTable() {
    DOMScheduler.schedule('executionsTable', () => {
      renderExecutionsTable();
    });
  }

  function scheduleRenderEvents() {
    DOMScheduler.schedule('eventsRender', () => {
      renderEventsPagination();
      renderEventsTable();
    });
  }

  let allExecutions = [];
  let filteredExecutions = [];

  let allEvents = [];
  let filteredEvents = [];
  let currentEventsPage = 1;

  // === Dados de Teste para Pagina√ß√£o ===
  // Adicionar dados fake para testar pagina√ß√£o
  function addTestData() {
    // Adicionar 25 execu√ß√µes fake
    for (let i = 1; i <= 25; i++) {
      allExecutions.push({
        id: `exec_${i}`,
        status: i % 4 === 0 ? 'failed' : i % 3 === 0 ? 'completed' : i % 2 === 0 ? 'running' : 'queued',
        algorithm: `Algorithm ${i}`,
        dataset: `Dataset ${i}`,
        config: `Config ${i}`,
        task: `Task ${i}`,
        started_at: Date.now() - (i * 60000),
        completed_at: i % 2 === 0 ? Date.now() - (i * 30000) : null
      });
    }

    // Adicionar 30 eventos fake
    for (let i = 1; i <= 30; i++) {
      allEvents.push({
        id: i,
        event_type: i % 4 === 0 ? 'error' : i % 3 === 0 ? 'warning' : i % 2 === 0 ? 'info' : 'progress',
        event_category: `category_${i % 5}`,
        timestamp: Date.now() - (i * 30000),
        entity_data: { message: `Mensagem de teste ${i}`, details: `Detalhes ${i}` }
      });
    }

    // Aplicar dados iniciais
    filteredExecutions = [...allExecutions];
    filteredEvents = [...allEvents];

    console.log('Dados de teste adicionados:', { executions: allExecutions.length, events: allEvents.length });

    // Renderizar dados de teste imediatamente (agendado)
    scheduleRenderExecutionsTable();
    scheduleRenderEvents();
  }

  // Chamar fun√ß√£o de teste na inicializa√ß√£o (comentar para usar dados reais)
  // addTestData();

  // === Fun√ß√µes Globais de Pagina√ß√£o/Render ===
  function formatStatusBadge(status) {
    const map = { running: 'primary', completed: 'success', queued: 'info', failed: 'danger', error: 'danger', paused: 'warning' };
    const cls = map[status] || 'secondary';
    return `<span class="badge bg-${cls} small">${(status || '').toUpperCase()}</span>`;
  }

  function formatTime(ts) {
    const d = new Date(ts * 1000);
    return d.toLocaleTimeString();
  }

  function escapeHtml(str) {
    return str.replace(/[&<>'"]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", "\"": "&quot;" }[c]));
  }

  // Fun√ß√µes de formata√ß√£o para eventos
  function formatEventTime(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.toLocaleTimeString('pt-BR', { hour12: false });
  }

  function formatEventType(type) {
    const typeClass = `event-type-${type}`;
    return `<span class="badge ${typeClass}">${type.toUpperCase()}</span>`;
  }

  function formatEventData(entityData) {
    try {
      const jsonStr = JSON.stringify(entityData, null, 2);
      const truncated = jsonStr.length > 100 ? jsonStr.substring(0, 100) + '...' : jsonStr;
      return `<code class="event-data" title="${jsonStr.replace(/"/g, '&quot;')}">${truncated.replace(/[&<>'"]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', "'": "&#39;", '"': '&quot;' }[c]))}</code>`;
    } catch {
      return '<code class="event-data">Invalid JSON</code>';
    }
  }

  function changeEventsPage(page) {
    const totalPages = Math.ceil(filteredEvents.length / ITEMS_PER_PAGE);
    if (page < 1 || page > totalPages) return;

    currentEventsPage = page;
    renderEventsPagination();
    renderEventsTable();
  }

  function renderEventsPagination() {
    const totalPages = Math.ceil(filteredEvents.length / ITEMS_PER_PAGE);
    const paginationContainer = document.getElementById('eventsPagination');
    const infoContainer = document.getElementById('eventsInfo');

    if (!paginationContainer) return;

    // Atualizar informa√ß√µes
    const start = (currentEventsPage - 1) * ITEMS_PER_PAGE + 1;
    const end = Math.min(currentEventsPage * ITEMS_PER_PAGE, filteredEvents.length);
    if (infoContainer) infoContainer.textContent = `Mostrando ${start}-${end} de ${filteredEvents.length} eventos`;

    if (totalPages <= 1) {
      paginationContainer.innerHTML = '';
      return;
    }

    let html = '';

    // Bot√£o anterior
    html += `<li class="page-item ${currentEventsPage === 1 ? 'disabled' : ''}">
    <a class="page-link" href="#" onclick="changeEventsPage(${currentEventsPage - 1}); return false;">Anterior</a>
  </li>`;

    // P√°ginas
    for (let i = 1; i <= totalPages; i++) {
      if (i === currentEventsPage) {
        html += `<li class="page-item active"><span class="page-link">${i}</span></li>`;
      } else {
        html += `<li class="page-item"><a class="page-link" href="#" onclick="changeEventsPage(${i}); return false;">${i}</a></li>`;
      }
    }

    // Bot√£o pr√≥ximo
    html += `<li class="page-item ${currentEventsPage === totalPages ? 'disabled' : ''}">
    <a class="page-link" href="#" onclick="changeEventsPage(${currentEventsPage + 1}); return false;">Pr√≥ximo</a>
  </li>`;

    paginationContainer.innerHTML = html;
  }

  function renderExecutionsTable() {
    // Ordenar execu√ß√µes por sequ√™ncia (igual √† fun√ß√£o original)
    const sortedExecutions = [...filteredExecutions].sort((a, b) => (a.sequencia || 0) - (b.sequencia || 0));

    // Renderizar todas as execu√ß√µes sem pagina√ß√£o
    const tbody = document.getElementById('executionsTableBody');
    if (!tbody) return;

    if (sortedExecutions.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" class="text-center text-muted py-4"><i class="bi bi-inbox me-1"></i>Nenhuma execu√ß√£o</td></tr>';
      return;
    }

    // Renderizar todas as execu√ß√µes
    tbody.innerHTML = sortedExecutions.map(exec => {
      const progressWidth = Math.round((exec.progress || 0) * 100);
      const tableClass = exec.status === 'running' ? ' class="table-info"' : '';

      return `<tr${tableClass}>
        <td class="text-muted">${exec.sequencia || '‚Äî'}</td>
        <td>${formatStatusBadge(exec.status)}</td>
        <td><div class="progress" style="height:6px;"><div class="progress-bar" style="width:${progressWidth}%"></div></div></td>
        <td>${exec.started_at ? formatTime(exec.started_at) : '‚Äî'}</td>
        <td>${exec.finished_at ? formatTime(exec.finished_at) : '‚Äî'}</td>
        <td class="small">${escapeHtml(exec.progress_message || '')}</td>
      </tr>`;
    }).join('');

    // Atualizar informa√ß√µes de contagem
    const infoContainer = document.getElementById('executionsInfo');
    if (infoContainer) {
      infoContainer.textContent = `Mostrando ${sortedExecutions.length} execu√ß√µes`;
    }
  }

  function renderEventsTable() {
    const tbody = document.getElementById('eventLogTableBody');
    if (!tbody) return;

    if (filteredEvents.length === 0) {
      tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted py-4"><i class="bi bi-inbox me-1"></i>Nenhum evento encontrado</td></tr>';
      return;
    }

    // Ordenar por timestamp (mais novos primeiro) - igual √† fun√ß√£o original
    const sortedEvents = [...filteredEvents].sort((a, b) => b.timestamp - a.timestamp);

    // Aplicar pagina√ß√£o
    const start = (currentEventsPage - 1) * ITEMS_PER_PAGE;
    const end = start + ITEMS_PER_PAGE;
    const pageEvents = sortedEvents.slice(start, end);

    // Renderizar eventos usando a mesma estrutura da fun√ß√£o original
    tbody.innerHTML = pageEvents.map(event => `<tr>
        <td class="event-timestamp">${formatEventTime(event.timestamp)}</td>
        <td>${formatEventType(event.event_type)}</td>
        <td><span class="badge bg-secondary">${event.event_category}</span></td>
        <td class="event-data">${formatEventData(event.entity_data)}</td>
      </tr>`).join('');
  }

  // === Nova implementa√ß√£o de monitoramento de progresso ===
  (() => {
    const WORK_ID = '{{ work_id }}';

    // Referencias dos elementos
    const els = {
      statusBadge: document.getElementById('workStatusBadge'),
      startTime: document.getElementById('startTime'),
      // Hierarchy
      taskProgress: document.getElementById('taskProgress'),
      datasetProgress: document.getElementById('datasetProgress'),
      configProgress: document.getElementById('configProgress'),
      algorithmProgress: document.getElementById('algorithmProgress'),
      // Current combination
      currentTask: document.getElementById('currentTaskValue'),
      currentDataset: document.getElementById('currentDatasetValue'),
      currentConfig: document.getElementById('currentConfigValue'),
      currentAlgorithm: document.getElementById('currentAlgorithmValue'),
      // Progress ring
      progressPercent: document.getElementById('progressPercent'),
      progressCircle: document.getElementById('progressCircle'),
      progressRatio: document.getElementById('progressRatio'),
      // Execution controls
      comboSelect: document.getElementById('combinationSelect'),
      autoFollowBtn: document.getElementById('autoFollowBtn'),
      statRunning: document.getElementById('statRunning'),
      statCompleted: document.getElementById('statCompleted'),
      statQueued: document.getElementById('statQueued'),
      statFailed: document.getElementById('statFailed'),
      comboProgressBar: document.getElementById('comboProgressBar'),
      comboProgressLabel: document.getElementById('comboProgressLabel'),
      // Action buttons
      btnGoToResult: document.getElementById('btnGoToResult'),
      btnPauseWork: document.getElementById('btnPauseWork'),
      btnContinueWork: document.getElementById('btnContinueWork'),
    };

    // Estado global
    let workStatusCache = null;
    let progressCache = null;
    let ws = null;
    let wsRetry = 0;
    const CIRCUMFERENCE = 2 * Math.PI * 60; // r=60

    // Execu√ß√µes/combo
    let allCombinations = [];
    let filteredEvents = [];
    let currentCombinationId = null;

    // Filtros
    let selectedCombinationId = null;
    let autoFollow = true;

    // Utils locais (mantidos)
    function formatStatusBadge(status) {
      const map = { running: 'primary', completed: 'success', queued: 'info', failed: 'danger', error: 'danger', paused: 'warning' };
      const cls = map[status] || 'secondary';
      return `<span class="badge bg-${cls} small">${(status || '').toUpperCase()}</span>`;
    }

    function formatTime(ts) {
      const d = new Date(ts * 1000);
      return d.toLocaleTimeString();
    }

    function escapeHtml(str) {
      return str.replace(/[&<>'"]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", "\"": "&quot;" }[c]));
    }

    // Fun√ß√µes de API
    async function fetchWorkStatus() {
      try {
        const resp = await fetch(`/api/monitor/work/${WORK_ID}/status`);
        if (!resp.ok) return;
        const data = await resp.json();
        workStatusCache = data;
        updateStatusBadge(data.status);
        updateStartTime();

        // Buscar nome do batch
        await fetchBatchName();
      } catch (_) { /* ignore */ }
    }

    // Buscar nome do batch
    async function fetchBatchName() {
      try {
        const resp = await fetch(`/api/monitor/works`);
        if (!resp.ok) return;
        const data = await resp.json();
        const work = data.works.find(w => w.id === WORK_ID);
        if (work && work.config_name) {
          document.getElementById('batchName').textContent = work.config_name;
        }
      } catch (_) { /* ignore */ }
    }

    // Fun√ß√µes de UI
    function updateStatusBadge(status) {
      if (!els.statusBadge) return;
      const map = {
        running: 'bg-primary',
        queued: 'bg-info',
        completed: 'bg-success',
        failed: 'bg-danger',
        error: 'bg-danger',
        paused: 'bg-warning',
        cancelled: 'bg-secondary'
      };
      els.statusBadge.className = 'badge status-badge ' + (map[status] || 'bg-secondary');
      els.statusBadge.textContent = status?.toUpperCase() || 'UNKNOWN';

      // Atualizar visibilidade dos bot√µes de controle
      updateWorkActionButtons(status);
    }

    function updateStartTime() {
      if (!workStatusCache || !els.startTime) return;
      const { created_at } = workStatusCache;
      if (!created_at) return;
      const startDate = new Date(created_at * 1000);
      const startTimeStr = startDate.toLocaleString('pt-BR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
      els.startTime.textContent = startTimeStr;
    }

    // Fun√ß√µes de controle de work (pausar/continuar)
    async function pauseWork() {
      if (!WORK_ID || !els.btnPauseWork) return;

      // Desabilitar bot√£o e mostrar loading
      els.btnPauseWork.disabled = true;
      const contentEl = els.btnPauseWork.querySelector('.btn-content');
      const loadingEl = els.btnPauseWork.querySelector('.btn-loading');
      contentEl?.classList.add('d-none');
      loadingEl?.classList.remove('d-none');

      try {
        const response = await fetch(`/api/monitor/work/${WORK_ID}/action/pause`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        const result = await response.json();

        if (!response.ok) {
          throw new Error(result.detail || 'Erro ao pausar work');
        }

        console.log('Work pausado com sucesso:', result);

        // N√£o desabilitar o bot√£o aqui - apenas restaurar o estado original
        // O status ser√° atualizado via WebSocket

      } catch (error) {
        console.error('Erro ao pausar work:', error);
        alert(`Erro ao pausar work: ${error.message}`);
      } finally {
        // Restaurar o bot√£o (sempre executado)
        els.btnPauseWork.disabled = false;
        contentEl?.classList.remove('d-none');
        loadingEl?.classList.add('d-none');
      }
    }

    async function continueWork() {
      if (!WORK_ID || !els.btnContinueWork) return;

      // Desabilitar bot√£o e mostrar loading
      els.btnContinueWork.disabled = true;
      const contentEl = els.btnContinueWork.querySelector('.btn-content');
      const loadingEl = els.btnContinueWork.querySelector('.btn-loading');
      contentEl?.classList.add('d-none');
      loadingEl?.classList.remove('d-none');

      try {
        const response = await fetch(`/api/monitor/work/${WORK_ID}/action/restart`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        const result = await response.json();

        if (!response.ok) {
          throw new Error(result.detail || 'Erro ao continuar work');
        }

        console.log('Work continuado com sucesso:', result);

        // N√£o desabilitar o bot√£o aqui - apenas restaurar o estado original
        // O status ser√° atualizado via WebSocket

      } catch (error) {
        console.error('Erro ao continuar work:', error);
        alert(`Erro ao continuar work: ${error.message}`);
      } finally {
        // Restaurar o bot√£o (sempre executado)
        els.btnContinueWork.disabled = false;
        contentEl?.classList.remove('d-none');
        loadingEl?.classList.add('d-none');
      }
    }

    // Atualizar visibilidade dos bot√µes baseado no status
    function updateWorkActionButtons(status) {
      if (!els.btnPauseWork || !els.btnContinueWork) return;

      // Ocultar ambos por padr√£o
      els.btnPauseWork.style.display = 'none';
      els.btnContinueWork.style.display = 'none';

      // Mostrar bot√£o apropriado baseado no status
      if (status === 'running') {
        els.btnPauseWork.style.display = 'inline-block';
      } else if (status === 'paused') {
        els.btnContinueWork.style.display = 'inline-block';
      }
    }

    // Aplicar dados de progresso do backend
    function applyProgress(progress) {
      progressCache = progress;
      try {
        // Hierarchy counts
        if (progress.tasks && els.taskProgress) {
          const fin = progress.tasks.Finished || 0;
          const runPlus = progress.tasks.Running ? 1 : 0;
          els.taskProgress.textContent = `${fin + runPlus}/${progress.tasks.Total || 0}`;
        }
        if (progress.datasets && els.datasetProgress) {
          const fin = progress.datasets.Finished || 0;
          const runPlus = progress.datasets.Running ? 1 : 0;
          els.datasetProgress.textContent = `${fin + runPlus}/${progress.datasets.Total || 0}`;
        }
        if (progress.configs && els.configProgress) {
          const fin = progress.configs.Finished || 0;
          const runPlus = progress.configs.Running ? 1 : 0;
          els.configProgress.textContent = `${fin + runPlus}/${progress.configs.Total || 0}`;
        }
        if (progress.algorithms && els.algorithmProgress) {
          const fin = progress.algorithms.Finished || 0;
          const runPlus = progress.algorithms.Running ? 1 : 0;
          els.algorithmProgress.textContent = `${fin + runPlus}/${progress.algorithms.Total || 0}`;
        }

        // Current combination context
        const cur = progress.current_combination_details || {};
        if (els.currentTask) els.currentTask.textContent = cur.task_id || '‚Äî';
        if (els.currentDataset) els.currentDataset.textContent = cur.dataset_id || '‚Äî';
        if (els.currentConfig) els.currentConfig.textContent = cur.preset_id || '‚Äî';
        if (els.currentAlgorithm) els.currentAlgorithm.textContent = cur.algorithm_id || '‚Äî';

        // Atualizar combina√ß√£o atual
        const newCurrentCombinationId = cur.combination_id || null;
        if (newCurrentCombinationId !== currentCombinationId) {
          currentCombinationId = newCurrentCombinationId;
          // Se auto-follow est√° ativo, atualizar sele√ß√£o
          if (autoFollow && currentCombinationId) {
            selectedCombinationId = currentCombinationId;
            updateCombinationSelect();
            filterAndRenderExecutions();
          }
        }

        // Global progress ring
        const gp = progress.global_progress || 0;
        const pct = Math.round(gp * 100);
        if (els.progressPercent) els.progressPercent.textContent = pct + '%';
        if (els.progressCircle) {
          const dash = (gp * CIRCUMFERENCE).toFixed(2);
          els.progressCircle.setAttribute('stroke-dasharray', `${dash} ${CIRCUMFERENCE}`);
        }
        if (progress.global_execution && els.progressRatio) {
          const f = progress.global_execution.Finished || 0;
          const t = progress.global_execution.Total || 0;
          els.progressRatio.textContent = `${f}/${t}`;
        }

      } catch (err) {
        console.warn('Failed to apply progress summary', err);
      }
    }

    // Atualizar dropdown de combina√ß√µes
    function updateCombinationSelect() {
      if (!els.comboSelect) return;
      const prev = els.comboSelect.value;
      els.comboSelect.innerHTML = '';

      // Op√ß√£o vazia
      const emptyOpt = document.createElement('option');
      emptyOpt.value = '';
      emptyOpt.textContent = 'Todas as combina√ß√µes';
      els.comboSelect.appendChild(emptyOpt);

      // Op√ß√µes das combina√ß√µes
      allCombinations.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c.combination_id;
        opt.textContent = `${c.task_id}/${c.dataset_id}/${c.preset_id}/${c.algorithm_id}`;
        els.comboSelect.appendChild(opt);
      });

      // Restaurar sele√ß√£o ou definir baseado no estado atual
      if (selectedCombinationId) {
        els.comboSelect.value = selectedCombinationId;
      } else if (prev && [...els.comboSelect.options].some(o => o.value === prev)) {
        els.comboSelect.value = prev;
        selectedCombinationId = prev || null;
      }
    }

    // Atualizar estado visual do bot√£o auto-follow
    function updateAutoFollowButton() {
      if (!els.autoFollowBtn) return;
      if (autoFollow) {
        els.autoFollowBtn.classList.add('active');
        els.autoFollowBtn.title = 'Auto-follow ativo - clique para desativar';
      } else {
        els.autoFollowBtn.classList.remove('active');
        els.autoFollowBtn.title = 'Auto-follow inativo - clique para ativar';
      }
    }

    // Filtrar e renderizar execu√ß√µes baseado na sele√ß√£o atual
    function filterAndRenderExecutions() {
      filteredExecutions = allExecutions;

      // Filtrar por combina√ß√£o se uma estiver selecionada
      if (selectedCombinationId) {
        filteredExecutions = allExecutions.filter(exec =>
          idsEqual(exec.combination_id, selectedCombinationId)
        );
      }

      // Calcular estat√≠sticas
      const stats = computeExecutionStats(filteredExecutions);

      // Renderizar sem pagina√ß√£o
      renderExecutions(filteredExecutions, stats);
    }

    function idsEqual(a, b) {
      if (a == null || b == null) return false;
      return String(a) === String(b);
    }

    function computeExecutionStats(executions) {
      const stats = { Running: 0, Completed: 0, Queued: 0, Failed: 0, Total: 0 };

      // Total √© o n√∫mero de execu√ß√µes
      stats.Total = executions.length;

      executions.forEach(exec => {
        if (exec.status === 'running') stats.Running++;
        else if (exec.status === 'completed') stats.Completed++;
        else if (exec.status === 'queued') stats.Queued++;
        else if (exec.status === 'failed' || exec.status === 'error') stats.Failed++;
      });

      return stats;
    }

    // Corrigido: renderExecutions sem vari√°veis indefinidas e auto-scroll ass√≠ncrono
    function renderExecutions(executions, stats) {
      // Atualizar estat√≠sticas
      if (els.statRunning) els.statRunning.textContent = stats.Running || 0;
      if (els.statCompleted) els.statCompleted.textContent = stats.Completed || 0;
      if (els.statQueued) els.statQueued.textContent = stats.Queued || 0;
      if (els.statFailed) els.statFailed.textContent = stats.Failed || 0;

      // Atualizar barra de progresso
      const tot = stats.Total || 0;
      const done = (stats.Completed || 0) + (stats.Failed || 0);
      if (els.comboProgressBar) {
        const pct = tot ? Math.round((done / tot) * 100) : 0;
        els.comboProgressBar.style.width = pct + '%';
        els.comboProgressBar.textContent = pct + '%';
      }
      if (els.comboProgressLabel) els.comboProgressLabel.textContent = `${done}/${tot}`;

      // Render da tabela (ass√≠ncrono/coalescente)
      DOMScheduler.schedule('executionsTable', () => renderExecutionsTable());

      // Auto-scroll ap√≥s render (ass√≠ncrono)
      if (autoFollow && currentCombinationId && selectedCombinationId === currentCombinationId) {
        DOMScheduler.schedule('executionsAutoscroll', () => {
          const container = document.getElementById('executionsContainer');
          const tbody = document.getElementById('executionsTableBody');
          if (!container || !tbody) return;
          const runningRow = tbody.querySelector('tr.table-info');
          if (runningRow) {
            const rowTop = runningRow.offsetTop;
            const containerHeight = container.clientHeight;
            const scrollTop = rowTop - (containerHeight / 2) + (runningRow.offsetHeight / 2);
            container.scrollTo({ top: Math.max(0, scrollTop), behavior: 'smooth' });
          }
        });
      }
    }

    function mergePartialProgress(partial) {
      if (!progressCache) return;

      const keys = ['tasks', 'datasets', 'configs', 'algorithms', 'execution', 'global_execution', 'current_combination_details', 'global_progress'];
      for (const k of keys) {
        if (partial[k] !== undefined) {
          if (typeof partial[k] === 'object' && partial[k] !== null && !Array.isArray(partial[k]) && typeof progressCache[k] === 'object') {
            progressCache[k] = { ...progressCache[k], ...partial[k] };
          } else {
            progressCache[k] = partial[k];
          }
        }
      }
      applyProgress(progressCache);
    }

    // Merge de execu√ß√µes - acumula execu√ß√µes sem duplicar
    function mergeExecutions(newExecutions) {
      if (!Array.isArray(newExecutions)) return;

      // Criar um mapa das execu√ß√µes existentes por chave √∫nica
      const existingMap = new Map();
      allExecutions.forEach(exec => {
        // Usar combination_id + sequencia como chave √∫nica
        const key = `${exec.combination_id || 'null'}_${exec.sequencia || 'null'}`;
        existingMap.set(key, exec);
      });

      // Adicionar ou atualizar execu√ß√µes
      newExecutions.forEach(newExec => {
        const key = `${newExec.combination_id || 'null'}_${newExec.sequencia || 'null'}`;

        if (existingMap.has(key)) {
          // Atualizar execu√ß√£o existente (merge dos dados)
          const existing = existingMap.get(key);
          Object.assign(existing, newExec);
        } else {
          // Adicionar nova execu√ß√£o
          allExecutions.push(newExec);
          existingMap.set(key, newExec);
        }
      });
    }

    // WebSocket - usando DOMScheduler diretamente
    function initWebSocket() {
      try {
        const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
        const url = `${scheme}://${location.host}/ws/work/${WORK_ID}`;
        ws = new WebSocket(url);

        ws.onopen = () => {
          wsRetry = 0;
          console.log('[WEBSOCKET] üü¢ WebSocket conectado para work:', WORK_ID, 'timestamp:', new Date().toISOString());
        };

        ws.onmessage = (evt) => {
          try {
            const msg = JSON.parse(evt.data);
            console.log('[WEBSOCKET] üì® Mensagem recebida:', {
              type: msg.type,
              work_id: msg.work_id,
              timestamp: new Date().toISOString(),
              message_timestamp: msg.timestamp ? new Date(msg.timestamp * 1000).toISOString() : null,
              payload_keys: msg.payload ? Object.keys(msg.payload) : null
            });

            if (msg.type === 'snapshot') {
              if (msg.payload?.progress) {
                DOMScheduler.schedule('applyProgress', () => applyProgress(msg.payload.progress));
              }
              if (msg.payload?.executions) {
                allExecutions = msg.payload.executions;
                DOMScheduler.schedule('executions', () => filterAndRenderExecutions());
              }
              if (msg.payload?.combinations) {
                allCombinations = msg.payload.combinations;
                DOMScheduler.schedule('comboSelect', () => updateCombinationSelect());
              }
              if (msg.payload?.events) {
                window.eventsManager?.setEvents(msg.payload.events);
              }
            } else if (msg.type === 'update') {
              if (msg.payload?.progress || msg.update?.progress) {
                const progressUpdate = msg.payload?.progress || msg.update?.progress;
                DOMScheduler.schedule('mergeProgress', () => mergePartialProgress(progressUpdate));
              }
              if (msg.payload?.executions || msg.update?.executions) {
                const newExecutions = msg.payload?.executions || msg.update?.executions;
                DOMScheduler.schedule('mergeExecutions', () => {
                  mergeExecutions(newExecutions);
                  filterAndRenderExecutions();
                });
              }
              if (msg.payload?.combinations || msg.update?.combinations) {
                allCombinations = msg.payload?.combinations || msg.update?.combinations;
                DOMScheduler.schedule('comboSelect', () => updateCombinationSelect());
              }
              if (msg.payload?.events_appended || msg.update?.events_appended) {
                const newEvents = msg.payload?.events_appended || msg.update?.events_appended;
                window.eventsManager?.addEvents(newEvents);
              }
            } else if (msg.type === 'event') {
              if (msg.payload?.event_type === 'work_status_changed') {
                const oldStatus = msg.payload.old_status;
                const newStatus = msg.payload.new_status;
                console.log('[WEBSOCKET] üîÑ Status do work mudou:', {
                  old_status: oldStatus,
                  new_status: newStatus,
                  timestamp: new Date().toISOString(),
                  message_timestamp: msg.timestamp ? new Date(msg.timestamp * 1000).toISOString() : null,
                  work_id: WORK_ID
                });

                // Verificar se √© um status final
                const finalStatuses = ['completed', 'failed', 'cancelled', 'error'];
                if (finalStatuses.includes(newStatus)) {
                  console.log('[WEBSOCKET] ‚ö†Ô∏è Status final detectado:', newStatus, '- WebSocket pode ser fechado em breve');
                }

                if (workStatusCache) {
                  workStatusCache.status = newStatus;
                  workStatusCache.updated_at = msg.timestamp || Date.now() / 1000;
                }

                updateStatusBadge(newStatus);
                updateStartTime();
              }
            }
          } catch (e) {
            console.error('[WEBSOCKET] ‚ùå Erro ao processar mensagem WebSocket:', e, 'dados:', evt.data);
          }
        };

        ws.onclose = (event) => {
          console.log('[WEBSOCKET] üî¥ WebSocket desconectado:', {
            code: event.code,
            reason: event.reason || 'Sem raz√£o espec√≠fica',
            wasClean: event.wasClean,
            timestamp: new Date().toISOString(),
            work_id: WORK_ID,
            retry_count: wsRetry
          });

          // C√≥digos de fechamento mais comuns:
          // 1000 = Normal closure
          // 1001 = Going away (e.g., server shutdown, browser navigation)
          // 1006 = Abnormal closure (no close frame received)
          if (event.code === 1000) {
            console.log('[WEBSOCKET] ‚ÑπÔ∏è Fechamento normal - provavelmente trabalho finalizado');
          } else if (event.code === 1001) {
            console.log('[WEBSOCKET] ‚ö†Ô∏è Servidor indo embora ou navega√ß√£o');
          } else if (event.code === 1006) {
            console.log('[WEBSOCKET] ‚ö†Ô∏è Fechamento anormal - conex√£o perdida');
          }

          scheduleReconnect();
        };

        ws.onerror = (err) => {
          console.error('[WEBSOCKET] ‚ùå Erro no WebSocket:', {
            error: err,
            timestamp: new Date().toISOString(),
            work_id: WORK_ID,
            readyState: ws?.readyState
          });
          try { ws.close(); } catch (_) { }
        };
      } catch (err) {
        console.warn('Erro ao inicializar WebSocket:', err);
        scheduleReconnect();
      }
    }

    function scheduleReconnect() {
      if (wsRetry > 6) {
        console.log('[WEBSOCKET] ‚õî M√°ximo de tentativas de reconex√£o atingido (6)');
        return;
      }
      const delay = Math.min(10000, 500 * Math.pow(2, wsRetry++));
      console.log('[WEBSOCKET] üîÑ Agendando reconex√£o em', delay, 'ms (tentativa', wsRetry, 'de 6)');
      setTimeout(initWebSocket, delay);
    }

    function setupEventListeners() {
      // Dropdown de combina√ß√µes
      els.comboSelect?.addEventListener('change', (e) => {
        selectedCombinationId = e.target.value || null;
        // Se selecionou uma combina√ß√£o espec√≠fica, desativar auto-follow
        if (selectedCombinationId) {
          autoFollow = false;
          updateAutoFollowButton();
        }
        filterAndRenderExecutions();
      });

      // Bot√£o auto-follow
      els.autoFollowBtn?.addEventListener('click', () => {
        autoFollow = !autoFollow;
        updateAutoFollowButton();

        if (autoFollow && currentCombinationId) {
          // Ativar auto-follow: selecionar combina√ß√£o atual
          selectedCombinationId = currentCombinationId;
          updateCombinationSelect();
          filterAndRenderExecutions();
        } else if (!autoFollow) {
          // Desativar auto-follow: mostrar todas
          selectedCombinationId = null;
          updateCombinationSelect();
          filterAndRenderExecutions();
        }
      });

      // Bot√µes de controle do work
      els.btnPauseWork?.addEventListener('click', pauseWork);
      els.btnContinueWork?.addEventListener('click', continueWork);
    }

    // Inicializa√ß√£o
    function init() {
      // Configurar estado inicial
      updateAutoFollowButton();

      // Configurar event listeners
      setupEventListeners();

      // Configurar bot√£o "Resultado"
      if (els.btnGoToResult) {
        els.btnGoToResult.addEventListener('click', () => {
          // Redireciona para a p√°gina de resultados com work_id em hash para futura sele√ß√£o autom√°tica
          window.open(`/results#work=${WORK_ID}`, '_blank');
        });
      }

      // Buscar dados iniciais
      fetchWorkStatus();
      initWebSocket();
    }

    // Inicializar quando o DOM estiver pronto
    init();
  })();

  // === Event Log Management ===
  (() => {
    // Estado dos eventos
    let autoScroll = false;

    // Referencias dos elementos
    const eventElements = {
      typeFilter: document.getElementById('eventTypeFilter'),
      categoryFilter: document.getElementById('eventCategoryFilter'),
      textFilter: document.getElementById('eventTextFilter'),
      dateFromFilter: document.getElementById('eventDateFromFilter'),
      dateToFilter: document.getElementById('eventDateToFilter'),
      autoScrollBtn: document.getElementById('btnAutoScroll'),
      table: document.getElementById('eventLogTable'),
      tableBody: document.getElementById('eventLogTableBody'),
      statsTotal: document.getElementById('eventStatsTotal'),
      statsErrors: document.getElementById('eventStatsErrors'),
      statsWarnings: document.getElementById('eventStatsWarnings'),
      statsProgress: document.getElementById('eventStatsProgress')
    };

    // Utilit√°rios
    function formatEventTime(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleTimeString('pt-BR', { hour12: false });
    }

    function formatEventType(type) {
      const typeClass = `event-type-${type}`;
      return `<span class="badge ${typeClass}">${type.toUpperCase()}</span>`;
    }

    function formatEventData(entityData) {
      try {
        const jsonStr = JSON.stringify(entityData, null, 2);
        const truncated = jsonStr.length > 100 ? jsonStr.substring(0, 100) + '...' : jsonStr;
        return `<code class="event-data" title="${jsonStr.replace(/"/g, '&quot;')}">${truncated.replace(/[&<>'"]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', "'": "&#39;", '"': '&quot;' }[c]))}</code>`;
      } catch {
        return '<code class="event-data">Invalid JSON</code>';
      }
    }

    // Filtros
    function matchesFilters(event) {
      // Filtro por tipo
      if (eventElements.typeFilter.value && event.event_type !== eventElements.typeFilter.value) {
        return false;
      }

      // Filtro por categoria
      if (eventElements.categoryFilter.value && event.event_category !== eventElements.categoryFilter.value) {
        return false;
      }

      // Filtro por texto (busca no entity_data)
      if (eventElements.textFilter.value) {
        const searchText = eventElements.textFilter.value.toLowerCase();
        const entityDataStr = JSON.stringify(event.entity_data || {}).toLowerCase();
        if (!entityDataStr.includes(searchText)) {
          return false;
        }
      }

      // Filtro por data (faixa de datas)
      const eventDate = new Date(event.timestamp * 1000);

      if (eventElements.dateFromFilter.value) {
        const fromDate = new Date(eventElements.dateFromFilter.value);
        if (eventDate < fromDate) {
          return false;
        }
      }

      if (eventElements.dateToFilter.value) {
        const toDate = new Date(eventElements.dateToFilter.value);
        if (eventDate > toDate) {
          return false;
        }
      }

      return true;
    }

    function applyFilters() {
      filteredEvents = allEvents.filter(matchesFilters);
      currentEventsPage = 1; // Resetar para primeira p√°gina
      renderEvents();
      updateStatistics();
    }

    // Renderiza√ß√£o
    function renderEvents() {
      if (!eventElements.tableBody) return;

      if (!filteredEvents.length) {
        eventElements.tableBody.innerHTML = '<tr><td colspan="4" class="text-center text-muted py-4"><i class="bi bi-inbox me-1"></i>Nenhum evento encontrado</td></tr>';
        DOMScheduler.schedule('eventsPagination', () => renderEventsPagination());
        return;
      }

      // Ordenar por timestamp (mais novos primeiro)
      const sortedEvents = [...filteredEvents].sort((a, b) => b.timestamp - a.timestamp);

      // Renderizar tabelas e pagina√ß√£o (agendado)
      scheduleRenderEvents();
    }

    function updateStatistics() {
      const stats = {
        total: filteredEvents.length,
        errors: filteredEvents.filter(e => e.event_type === 'error').length,
        warnings: filteredEvents.filter(e => e.event_type === 'warning').length,
        progress: filteredEvents.filter(e => e.event_type === 'progress').length
      };

      if (eventElements.statsTotal) eventElements.statsTotal.textContent = stats.total;
      if (eventElements.statsErrors) eventElements.statsErrors.textContent = stats.errors;
      if (eventElements.statsWarnings) eventElements.statsWarnings.textContent = stats.warnings;
      if (eventElements.statsProgress) eventElements.statsProgress.textContent = stats.progress;
    }

    // Fun√ß√µes p√∫blicas para o WebSocket
    window.eventsManager = {
      setEvents: function (events) {
        allEvents = events || [];
        applyFilters();
      },

      addEvents: function (newEvents) {
        if (!Array.isArray(newEvents)) return;

        // Adicionar novos eventos (evitar duplicatas por ID)
        const existingIds = new Set(allEvents.map(e => e.id));
        const uniqueNewEvents = newEvents.filter(e => !existingIds.has(e.id));

        if (uniqueNewEvents.length > 0) {
          allEvents.push(...uniqueNewEvents);

          // Se auto-refresh estiver ativo, ir para a primeira p√°gina
          if (autoScroll) {
            currentEventsPage = 1;
          }

          applyFilters();
        }
      }
    };

    // Event listeners
    function setupEventListeners() {
      // Filtros
      eventElements.typeFilter?.addEventListener('change', applyFilters);
      eventElements.categoryFilter?.addEventListener('change', applyFilters);
      eventElements.textFilter?.addEventListener('input', applyFilters);
      eventElements.dateFromFilter?.addEventListener('change', applyFilters);
      eventElements.dateToFilter?.addEventListener('change', applyFilters);

      // Bot√£o auto-scroll
      eventElements.autoScrollBtn?.addEventListener('click', () => {
        autoScroll = !autoScroll;
        if (autoScroll) {
          eventElements.autoScrollBtn.classList.add('active');
          eventElements.autoScrollBtn.title = 'Auto-refresh ativo - vai para primeira p√°gina quando houver novos eventos';
          // Ir para a primeira p√°gina
          currentEventsPage = 1;
          renderEventsPagination();
          renderEventsTable();
        } else {
          eventElements.autoScrollBtn.classList.remove('active');
          eventElements.autoScrollBtn.title = 'Auto-refresh inativo';
        }
      });
    }

    // Fun√ß√µes de pagina√ß√£o
    // Inicializa√ß√£o
    setupEventListeners();
  })();
</script>
{% endblock %}